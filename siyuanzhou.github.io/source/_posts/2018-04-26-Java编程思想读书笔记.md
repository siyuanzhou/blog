---
layout: post
title: "Java编程思想读书笔记"
date: 2018-04-26 10:36
comments: true
toc: true
categories: 技术学习
tags: 
	- Java
	- 读书
typora-root-url: ./
---

<!--more-->

##### java中字符串的比较是==比较引用，equals 比较值

so我们经常习惯性的写上if(str1==str2)，这种写法在java中可能会带来问题

1: String a="abc";String b="abc"

那么a==b将返回true。因为在java中字符串存在堆中，其值是不可改变的，相同的字符串在内存中只会存一份，

所以a和b都是同一个堆中的对象的地址；

```java
example2：String a=new String("abc"); String b=new String("abc");
```

 那么a==b将返回false，此时a和b指向不同的对象。

2、用equals方法比较的是字符串的内容是否相同，

```java
example：String a=new String("abc"); 
String b=new String("abc"); a.equals(b);将返回true。
```

##### Java构造器及初始化

Java只允许单继承，不允许多继承，接口可以实现多个；

 <1>.继承后构造子类顺序:先初始化父类，再初始化子类，先初始化属性在调用构造函数

如果你需要通过计算来初始化你的static变量，你可以声明一个static块，Static 块仅在该类被加载时执行一次。下面的例子显示的类有一个static方法，一些static变量，以及一个static 初始化块：

static定义的变量会优先于任何其它非static变量，不论其出现的顺序如何。在static{后面跟着一段代码，这是用来进行显式的静态变量初始化，这段代码只会初始化一次，且在类被第一次装载时。static在涉及到继承的时候，会先初始化父类的static变量，然后是子类的，依次类推。

```java
//问以下程序运行后输出什么
//答案: 0, p, 5
//解析见以下注释，按序号顺序查看
class A {
    A() {this.init(); }
    public void init() {// 3.该函数被覆盖
        System.out.println("q");
    }
}
class B extends A {
    public int i = 4;
    B(int i) { // 2.A构造函数先于B构造函数运行
        System.out.println("p");// 6.输出p
        this.i = i; // 7. i被赋值为5
    }
    public void init() {// 4.实际执行的函数
        // 5.此时 i 尚未初始化，为0
        System.out.println(i);
    }
    public static void main(String[] args) {
        // 1.程序开始运行
        System.out.println(new B(5).i);
        // 8.输出
    }       
}
```

##### 关于`comparator`的理解

我的理解是返回值决定位置是否需要调整，o1和o2是有顺序的，理解这点很重要，也就是o1排在o2后面（原数组），按照返回值大于0 ，来查看升序还是降序。

```java
                //降序
                if(option==0)
                {
                    Collections.sort(stuList, new Comparator<Student>()
                    {
                        public int compare(Student o1,Student o2)
                        {
                            return o2.score-o1.score;
                        }
                    });
                }
                else if(option==1)//升序
                {
                    Collections.sort(stuList, new Comparator<Student>()
                    {
                        public int compare(Student o1,Student o2)
                        {
                            return o1.score-o2.score;
                        }
                    });
                }
```

##### 中间缓存变量机制

```java
int j=0;
for(int i=0;i<100;i++)
{
	j=j++;
}
System.out.println(j);//j=0
/*
原因
temp=j;
j=j+1;
j=temp;
*/
```

##### java传参数

对基本变量，传的是值的副本，对对象型变量，传的引用型副本。

##### else问题

~~~java
if(true)
{
    A
}
else if(true)
{
    B
}
B不会执行，因为有else
~~~

##### Java编程思想中应注意的问题

private：只有自己可以访问
（default）：同包的可以访问
protected : 同包和不同包的派生类可以访问
public：都可以访问

```java
package javaSE;

import java.util.Random;

//一个单例模式
public class Singleton {
	private   Singleton() {}
	static private Singleton s=new Singleton();
	public static Singleton getSingleton ()
	{
		return s;		
	}		
}
abstract class reStudy{
	//可变参数列表
	public void canParameterChange(int... n)
	{
		for(int i:n)
		{
			System.out.println(i);
		}
	}
	//方法参数传递的是引用
	//static 隶属于类，只会生成一份，其他都是引用
	
	//java随机数，以当前时间毫秒数做种子
	public void testRandom()
	{
		Random rand=new Random();
		int j=rand.nextInt(100)+1;//1~100
		System.out.println(rand.nextFloat());//0~1
        System.out.println(rand.nextBoolean());
	}
	
	//==比较的是地址是否一样，equals比较的是值是否一样，需要在新类中重写equals方法
	
	//如果定义了构造器，则默认构造器无效
	
	//垃圾清理，自适应的，分代的，停止复制，标记清扫的垃圾回收器
	
	//初始化顺序，先基类后子类，是static在有类就初始化了，之后不会再初始化，其他非static块每次构造都运行，先static后变量后构造器
	
	//Arrays.toString(),返回数组的可打印版本，"12323".toCharArray(),返回字符数组
	
	//默认同包，private自己，protected自己和继承类，public都能访问
	
	//可以有多个main()方法，运行那个就是哪个
	
	//finally 总会被执行
	
	//@override可以确保被重载而不是覆写
	
	//is-a用继承 has-a用组合 慎用继承
	
	//常量的定义，final数据表示不可改变，对引用，表示引用的地址不可改变，值可能改变，final做参数表示无法更改,final方法和类也表示无法继承
	//private无法继承，如果子类有一样的函数，看做新的函数
	public static final int VALUEONE=6;
	
	//静态方法没有多态行
	//向上转型（向基类转型）不会出现错误，乡向下转型，会出现异常
	
	//抽象方法，如果有抽象方法，则类一定为抽象类
	public abstract void exampleAbstact(int i);
	
	
	
}
//接口
interface A{
	void play();
	void adjust(int i);
	
}
//接口实现类
class B implements A{

	@Override
	public void play() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void adjust(int i) {
		// TODO Auto-generated method stub
		
	}
	
}
```

